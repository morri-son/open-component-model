name: Release Candidate Version

on:
  workflow_call:
    inputs:
      branch:
        required: true
        type: string
        description: "Branch to cut to, must match regex releases/v0.[0-9]+"
      component_path:
        required: true
        type: string
        description: "Path to the CLI component, e.g. cli"
    outputs:
      new_tag:
        description: "New RC tag name (e.g. cli/v0.1.0-rc.3)"
        value: ${{ jobs.prepare.outputs.new_tag }}
      new_version:
        description: "New RC version (e.g. v0.1.0-rc.3)"
        value: ${{ jobs.prepare.outputs.new_version }}
      base_version:
        description: "Base version (e.g. v0.1.0-rc.1 -> v0.1.0)"
        value: ${{ jobs.prepare.outputs.base_version }}
      promotion_tag:
        description: "Tag to be used for promotion later, eg. cli/v0.1.0-rc.1 -> cli/v0.1.0"
        value: ${{ jobs.prepare.outputs.promotion_tag }}
      changelog_artifact:
        description: "Name of the changelog artifact"
        value: ${{ jobs.prepare.outputs.changelog_artifact }}
      set_latest:
        description: "Whether to set :latest tag (true if this version >= highest existing final)"
        value: ${{ jobs.prepare.outputs.set_latest }}
      highest_final_version:
        description: "Highest existing final version for this component (for logging)"
        value: ${{ jobs.prepare.outputs.highest_final_version }}

jobs:
  prepare:
    name: Tag & Changelog
    permissions:
      contents: read
    runs-on: ubuntu-latest
    outputs:
      new_tag: ${{ steps.compute.outputs.new_tag }}
      new_version: ${{ steps.compute.outputs.new_version }}
      base_version: ${{ steps.compute.outputs.base_version }}
      promotion_tag: ${{ steps.compute.outputs.promotion_tag }}
      changelog_artifact: changelog-${{ steps.compute.outputs.new_version }}
      set_latest: ${{ steps.latest.outputs.set_latest }}
      highest_final_version: ${{ steps.latest.outputs.highest_final_version }}
    steps:
      # Checkout the repository and target branch
      - name: Checkout Repository
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6
        with:
          sparse-checkout: |
            ${{ inputs.component_path }}
            .github/scripts
          fetch-depth: 0
          ref: ${{ inputs.branch }}
          token: ${{ secrets.GITHUB_TOKEN }}

      # Compute new RC version based on branch and existing tags
      - name: Compute new RC version
        id: compute
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        env:
          BRANCH: ${{ inputs.branch }}
          COMPONENT_PATH: ${{ inputs.component_path }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const script = await import('${{ github.workspace }}/.github/scripts/release-versioning.js');
            await script.default({ core, github, context });

      - name: Generate changelog with git-cliff
        uses: orhun/git-cliff-action@e16f179f0be49ecdfe63753837f20b9531642772 # v4
        id: git-cliff
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          config: ${{ inputs.component_path }}/cliff.toml
          args: |
            --include-path "${{ inputs.component_path }}/**" \
            --tag-pattern "^${{ inputs.component_path }}/v\\d+\\.\\d+\\.\\d+(?:[-\\w\\.]+)?$" \
            --ignore-tags "^${{ inputs.component_path }}/v\\d+\\.\\d+\\.\\d+-rc\\.\\d+$" \
            --tag "${{ steps.compute.outputs.new_tag }}" \
            -o "$RUNNER_TEMP/CHANGELOG.md" \
            --use-branch-tags \
            --latest

      - name: Summarize changelog
        id: summarize
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        env:
          CHANGELOG_FILE: ${{ runner.temp }}/CHANGELOG.md
          TAG: ${{ steps.compute.outputs.new_tag }}
        with:
          script: |
            const fs = require("fs");
            const tag = process.env.TAG;
            const today = new Date().toISOString().split("T")[0];

            // Read changelog file if it exists
            let log = "";
            if (fs.existsSync(process.env.CHANGELOG_FILE)) {
              log = fs.readFileSync(process.env.CHANGELOG_FILE, "utf8").trim();
            }

            // Generate fallback header if changelog is empty
            // This can happen when --use-branch-tags finds no tags on a new release branch
            if (!log) {
              log = `## [${tag}] - ${today}\n\nNo changes since the previous release.`;
              core.info(`Generated fallback changelog for ${tag}`);
              fs.writeFileSync(process.env.CHANGELOG_FILE, log);
            }

            await core.summary.addRaw(log).write();

      - name: Upload changelog artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: changelog-${{ steps.compute.outputs.new_version }}
          path: ${{ runner.temp }}/CHANGELOG.md
          retention-days: 90
          if-no-files-found: error

      - name: Determine if release should be latest
        id: latest
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        env:
          COMPONENT_PATH: ${{ inputs.component_path }}
          PROMOTION_VERSION: ${{ steps.compute.outputs.base_version }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const script = await import('${{ github.workspace }}/.github/scripts/release-versioning.js');
            await script.determineLatestRelease({ core, github, context });
